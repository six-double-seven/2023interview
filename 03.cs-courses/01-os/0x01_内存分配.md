### `Kernal Space`

内核空间。由于开发和维护内核的复杂性，只有最重要的和最关键的代码放置在内核中。其他内容通常是作为用户空间应用程序编程的。（避免一些敏感操作）

### `User Space`

> 用户态的程序不能随意操作内核空间，这样对操作系统具有一定的安全保护作用。


用户空间从高地址到低地址依次分为如下五个区：

#### `.stack`

栈区。**编译器**在需要的时候分配，不需要时自动清除的变量所在的储存区。

- 由编译器自动管理
- 程序运行时分配内存
- 使用效率高、但空间有限。
- 从高地址向低地址扩展，内存连续。
- 先进后出
- 存放：函数的入口参数、局部变量等

#### `.heap`

堆区。由程序员手动分配释放的储存区。忘记释放会造成内存泄漏。

- 程序员手动管理(手动申请、释放)
- 程序运行时分配内存
- 空间大，可以是不连续的。
- 从低地址向高地址扩展
- 先进先出
- `malloc、realloc`等开辟的空间即堆区的空间

#### `.bbs segment`

全局/静态区。用来存放全局变量、静态变量的区域；当程序运行结束后由系统释放。

- 由编译器自动管理
- 编译时分配内存
- 存放全局变量、静态变量

#### `.data segment`

常量区。用来存放字符串字面量、`const`修饰的全局变量、静态变量。

- 由编译器自动管理
- 编译时分配内存
- 存放`const`全局变量、`const`静态变量、字符串字面量。

#### `.text segment`

代码区。用于存放CPU指令

- 由编译器自动管理
- 编译时分配内存
- 存放CPU指令

### 用户态/内核态

> 用户态  ---  进程运行在用户空间<br>内核态  ---  进程运行在内核空间

在**内核态**下，CPU 可以**执行任何指令**。运行的**代码也不受任何的限制**，可以**自由地访问任何有效地址**，也可以直接进行端口的访问。

在用户态下，被执行的代码要受到 CPU 的很多检查。

#### 系统调用

磁盘上文件的读写、内存空间的分配、网络接口读写数据等，都是在内核态完成的。平时使用时，借助操作系统提供的**系统调用接口**来进行使用。

> 应用程序读取文件大致步骤

1. 应用程序向内核发起系统调用，将进程从用户态切换为内核态。
2. CPU把数据读取到内核空间
3. 数据拷贝到用户空间，并将进程切换为用户态。
4. 应用程序得到相应的数据，执行其他命令。

库函数、Shell指令等就是利用操作系统提供的调用接口来实现用户态的程序向操作系统申请更高权限的服务。
