# 操作系统概念-第7版

>链接：https://pan.baidu.com/s/11SjaK3u3MY7mpmH1FkR2vA?pwd=r9yu 
>提取码：r9yu

# 1.进程

## 1.1 概念

### a. 进程

- 进程是执行中的程序；

- 进程包括**程序代码段**(文本段、代码段)、**数据段**(包括全局变量)、**堆**(进程运行期间动态分配的内存)、**栈段**(临时数据)；
- 进程还包括当前活动，通过**程序计数器**的值和**cpu寄存器**的内容表示。

![内存中的进程](images\内存中的进程.png)

### b. 程序 & 进程

- 程序只是被动实体，如存储在磁盘上包含一系列指令的文件内容（常被称为可执行文件)；
- 进程是活动实体，它有一个程序计数器用来表示下一个要执行的命令和相关资源集合。



### c. 进程状态

![进程状态图](images\进程状态图.png)

### d. 进程控制块(PCB)

每个进程在操作系统内用进程控制块( process control block，PCB，也称为任务控制块)，它包含许多与一个特定进程相关的信息，比如

- 进程状态

- 程序计数器：计数器表示进程要执行的下个指令的地址。

- CPU寄存器

  - CPU的状态信息存储于CPU中的各种寄存器中，CPU在运行时，许多信息放在寄存器中，当CPU被中断时，所有的CPU信息应从寄存器保存到PCB中，以便该进程重新执行时，能从断点继续执行。

  - CPU中主要有六类寄存器：指令寄存器（IR）、程序计数器（PC）、地址寄存器（AR）、数据寄存器（DR）、累加寄存器（AC）、程序状态字寄存器（PSW）
  - 与程序计数器一起，这些状态信息在出现中断时也需要保存，以便进程以后能正确地继续执行

- CPU调度信息：这类信息包括进程优先级、调度队列的指针和其他调度参数

- 内存管理信息：根据操作系统所使用的内存系统，这类信息包括基址和界限奇仔器的值、页表或段表

![PCB](images\PCB.png)

### e. cpu在进程之间切换

![cpu在进程之间切换](images\cpu在进程之间切换.png)

## 1.2 进程调度

>进程调度：选择一个可用的进程到CPU上执行。
>
>单cpu系统只允许 0 或 1 个进程在运行，如果有多个进程余下的则需要等待CPU空闲并重新调度。

### 1.2.1 调度队列

**1、作业队列**

- 作业队列包含系统中的所有进程；
- 进程首次进入系统时，会被添加到作业队列中；



**2、就绪队列**

- 驻留在内存中就绪的、等待运行的进程保存在就绪队列中；

- 就绪队列通常用链表来实现，其头节点指向链表的第一个和最后一个PCB块的指针，每个 PCB包含指向下一个PCB的指针。

  ![00.就绪队列](images\00.就绪队列.png)



**3、设备队列**

- 等待特定I/O设备的进程列表称为设备队列。每个设备都有自己的设备队列。



就绪队列和设备队列如下图所示。

![01.队列图](images\01.队列图.png)



**4、队列图**

圆形表示为队列服务的资源，箭头表示系统内进程的流向；

新进程开始处于就绪队列，当进程分配到CPU 并执行时，可能发生下面几种事件中的一种:

- 进程可能发出一个IO请求，并被放到IO队列中；
- 进程可能创建一个新的子进程，并等待其结束；
- 进程可能会由于中断而强制释放CPU，并被放回到就绪队列中。

用队列图表示上述情况，如下图所示。

![02-队列图](images\02-队列图.png)



### 1.2.2 调度程序

进程在其生命周期中会在各种调度队列之间迁移，迁移的完成是由**调度程序**(scheduler)完成。



**1、调度程序的分类**

(1) 长期调度程序(long-term scheduler) 或 作业调度程序 (job scheduler)：从磁盘的缓冲池中选择进程并装入内存，以准备执行；

- 长期调度程序应该选择一个合理的包含 I/O 为主的 和 CPU 为主的组合进程。如果所有进程均是 I/O 为主的，那么就绪队列几乎为空，从而短期调度程序没有什么事情可做；如果所有进程均是 CPU 为主的，那么 I/O  等待队列将几乎总为空，从而几乎不使用设备，因而系统会不平衡。为了达到最好性能，系统需要一个合理的 I/O 为主和 CPU 为主的组合进程。
- 对于 没有 长期调度程序的系统来讲，操作系统会将所有的新进程放在内存中以供短期调度程序使用，稳定性依赖于可用的物理限制(可用的终端数)或用户的自我调整。



(2) 短期调度程序 (short-term scheduler) 或 CPU 调度程序：从准备执行的进程中选择进程，并为之分配 CPU。



(3) 中期调度程序( medium-term scheduler) ：将进程从内存(或从 CPU 竞争)中移出，之后进程能被重新调入内存，并从中断处继续执行，又称为交换。

- 作用：为了改善进程组合，或者因内存要求的改变引起了可用内存的过度使用而需要释放内存，就有必要使用交换；

- 增加了中期调度的队列图如下。

  ![03-中期调度的队列图](images\03-中期调度的队列图.png)



**2、两种调度程序的差别**

(1) 长期调度程序

- 长期调度程序执行得并不频繁，长期调度程序 控制 多道程序设计的程度(内存中的进程数量)；
- 如果多道程序的程度稳定，那么创建进程的平均速度必须等于进程离开系统的平均速度；

(2) 短期调度程序

- 短期调度程序必须频繁地为CPU选择新进程；
- 进程可能执行数毫秒就会进行 I/O 请求，短期调度程序通常每 100ms 至少执行一次；
- 短期调度程序必须要快，尽可能将CPU时间用在进程执行而不是调度工作上。



**3、调度的过程**

(1) 进程被存储到磁盘的缓冲池

(2) 作业调度程序 在缓冲池中选择进程并装入内存，以准备执行；

(3) CPU调度程序 在就绪队列中选择进程，并为之分配 CPU。



**4、磁盘缓冲池**

通常对于批处理系统，进程更多地是被提交而不是马上执行，这些进程被放到大容量存储设备(通常为磁盘)的缓冲池中。

操作系统中有**缓冲池**(buffer pool)机制，避免每次访问磁盘，以加速数据的访问。



### 1.2.3 上下文切换

**1、状态保存 && 状态恢复**

当发生中断时：

- 通过执行一个状态保存( state save) 来保存 CPU 当前状态(不管它是内核模式还是用户模式)
- 之后执行一个状态恢复(state restore) 重新开始运行。



**2、上下文切换**

CPU 切换到另一个进程需要保存当前进程的状态并恢复另一个进程的状态，称为上下文切换。

上下文切换时间是额外开销，因为切换时系统并不能做其他有用的工作。



**3、上下文切换的过程**

(1) 内核会将旧进程的状态保存在 PCB 中；

(2) 装入新进程(经调度后确定要执行的并已经保存)的上下文；

## 1.3 进程操作



### 1.3.1 进程创建

**1、进程系统调用**

进程在其执行过程中，能通过创建进程系统调用 (create-process system cal l)创建多个新进程；

创建进程称为父进程，而新进程称为子进程；

每个新进程可以再创建其他进程，从而形成了进程树。



**2、进程树**

a进程运行的过程中，用户的某些操作会产生子进程 a-child1、a-child2，a-child2也可能会产生子进程 a-child21 ，形成进程树。

Solaris(UNIX系统的衍生版本之一)系统中的进程树如下图所示。

![04-进程树](images\04-进程树.png)



**3、创建子进程的条件**

(1) 资源的获取

- 在一个进程创建子进程时，子进程可能从操作系统那里直接获得资源，也可能只从其父进程那里获得资源；
- 进程可能必须在其子进程之间分配资源或共享资源(如内存或文件)

(2) 初始化数据

- 在进程创建时，初始化数据(或输入)由父进程传递给子进程；
- 新进程的 标识符 要传递给父进程，以便后续终止进程。



**4、父子进程执行的过程**

(1) 父进程 通过系统调用fork() 创建子进程；

(2) 子进程使用系统调用 exec()，开始执行；

(3) 如果在子进程执行的过程中父进程没什么可做，会调用wait()将自己移出就绪队列等待子进程的终止；

(4) 子进程执行完后调用exit()表示结束，系统调用wait()返回了终止子进程的**进程标识符pid**，通知给父进程。

![05-父子进程执行](images\05-父子进程执行.png)





### 1.3.2 进程终止

**1、进程终止 - 自身终止**

(1) 当进程完成执行完最后的语句并使用系统调用 exit() ，请求操作系统删除自身时，进程终止；

(2) 进程返回状态值(通常为整数)到父进程；

(3) 所有进程资源(包括物理和虚拟内存、打开文件和 I/O 缓冲)会被操作系统释放。



**2、进程终止 - 父进程终止其子进程**

(1) 进程通过适当的系统调用(如 Win32 中的TenninatePorcess) 终止其子进程；

(2) 通常只有被终止进程的父进程才能执行这一系统调用，且执行该系统调用需要已知其子进程的标识符。



**3、父进程终止其子进程的原因**

(1) 子进程使用了超过它所分配到的一些资源；(为判定是否发生这种情况，要求父进程有一个检查其子进程状态的机制)

(2) 分配给子进程的任务已不再需要；

(3) 父进程退出，如果父进程终止，那么操作系统不允许子进程继续。



**4、级联终止( cascading termination)**

(1) 有些系统，不允许子进程在父进程已终止的情况下存在；

​	 对于这类系统，如果一个进程终止(正常或不正常)，那么它的所有子进程也将终止；

(2) 级联终止通常由操作系统进行。



## 1.4 进程间通信

### 1.4.1 概念

**1、独立进程 & 协作进程**

(1) 独立进程：一个进程不能影响其他进程或被其他进程所影响；

(2) 协作进程：与其他进程共享数据的进程为协作进程，协作进程需要IPC来交换数据和信息。



**2、进程间通信的两种基本方式**

(1) 共享内存

- 在共享内存模式中，建立起一块供协作进程共享的内存区域，进程通过向此共享区域读或写入数据来交换信息；
- 建立共享内存区域时需要系统调用，一旦建立了共享内存，所有的访问都是常规的内存访问，**不需要内核**。

(2) 消息传递

- 通过在协作进程间交换消息来实现通信，多用于交换较少数量的数据；
- 消息传递通常需要 **系统调用** 来实现，因此需要更多的 **内核** 介入的时间消耗；
- 常用于 **分布式环境** 。

两种模式的对比图如下。

![通信模型](images\通信模型.png)



### 1.4.2 共享内存系统

**1、共享内存介绍**

(1) 采用共享内存的进程间通信 需要通信进程建立共享内存区域，一块共享内存区域驻留在生成共享内存段进程的地址空间，其他希望使用这个共享内存段进行通信的进程必须将此放到它们自己的地址空间上。

(2) 比如上图 通信模型 - 消息传递中，共享内存区域为M 。



**2、生产者 - 消费者**

(1) 共享内存解决生产者 - 消费者

- 为了允许生产者进程和消费进程能井发执行，必须要有一个缓冲来被生产者填充并被消费者所使用；
- 此缓冲驻留在生产者进程和消费者进程的共享内存区域内，当消费者使用一项时，生产者能产生另一项。
- 生产者和消费者必须同步，以免消费者消费一个没有生产出来的项。

(2) 具体的解决方案

- 无限缓冲( unbounded-buffer) 对缓冲大小没有限制。消费者可能不得不等待新的项，但生产者总是可以产生新项；
- 有限缓冲 (bounded-buffer) 假设缓冲大小固定。对于这种情况，如果缓冲为空，那么消费者必须等待；如果缓冲为满，那么生产者必须等待。



### 1.4.3 消息传递系统

**1、消息传递介绍**

(1) 由操作系统提供机制， 通过 **系统调用** 来实现，让协作进程能通过消息传递工具来进行通信；

(2) 消息传递工具提供至少两种操作：发送和接收；

(3) 如果进程 P、Q 需要通信，那么它们必须彼此相互发送消息和接收消息，它们之间必须要有通信线路。



**2、send()、receiven() 操作**

- 直接或间接通信
- 同步或异步通信
- 自动或显式缓冲



**3、命名管道**

需要通信的进程必须有一个方法以互相引用。它们可使用直接或间接通信。

(1) 直接通信 - 对称寻址

- 需要通信的每个进程必须 **明确** 命名通信的接收者或发送者；
- 原语 send()、receive() 定义如下
  - send(P，message) 发送消息到进程P；
  - receive(Q、message) 接收来自进程Q的消息；
- 直接通信的属性
  - 在需要通信的每对进程之间自动建立线路。进程仅需知道相互通信的标识符；
  - 一个线路只与两个进程相关；
  - 每对进程之间只有一个线路。

(2) 直接通信 - 非对称寻址

- 只要发送者命名接收者，而接收者不需要命名发送者；
- 原语 send()、receive() 定义如下
  - send(P，message) 发送消息到进程P；
  - receive(id，message) 接收来自任何进程的消息，**变量id**设置成与其通信的进程的名称。

(3) 间接通信

- 通过邮箱或端口来发送和接收消息。邮箱可以抽象成一个对象，进程可以向其中存放消息，也可从中删除消息，每个邮箱都有一个唯一的标识符；
- 原语 send()、receive() 定义如下
  - send(A，message) 发送消息到邮箱 A；
  - receive(A，message) 接收来自来自邮箱A的消息。
- 间接通信属性
  - 只有在两个进程共享一个邮箱时，才能建立通信线路；
  - 一个线路可以与两个或更多的进程相关联；
  - 两个通信进程之间可有多个不同的线路，每个线路对应于一个邮箱。



**4、同步**

消息传递可以是阻塞或非阻塞，也称为同步或异步，如下。

- 阻塞 send: 发送进程阻塞，直到消息被接收进程或邮箱所接收。
- 非阻塞 send: 发送进程发送消息并再继续操作。
- 阻塞 receive: 接收者阻塞，直到有消息可用。
- 非阻塞 receive: 接收者收到一个有效消息或空消息。



**5、缓冲**

不管通信是直接的或是间接的，通信进程所交换的消息都驻留在临时队列中，队列实现有三种方法

(1) 零容量：

​	队列的最大长度为 0，因此线路中不能有任何消息处于等待。对于这种情况，必须阻塞发送，直到接收者接收到消息。

(2) 有限容量：

​	队列的长度为有限的 n，因此最多只能有 个消息驻留其中。如果在发送新消息时队列未满，那么该消息可以放在队列中(或者复制消息或者保存消息的指针)，

且发送者可继续执行而不必等待。不过，线路容量有限。如果线路满，必须阻塞发送者直到队列中的空间可用为止。

(3) 无限容量：

​	队列长度可以无限，因此，不管多少消息都可在其中等待，从不阻塞发送者。

零容量情况称为没有缓冲的消息系统，其他情况称为自动缓冲。