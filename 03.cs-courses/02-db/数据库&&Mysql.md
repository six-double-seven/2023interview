# 数据库

## 1.基本概念

- 元组：数据库表的每一行是一个元组，每一列就是一个属性；
- 码：码是能唯一标识实体的属性，对应表中的列；
- 候选码：若关系中某一属性或属性组的值能唯一的标识一个元组，而其任何自己子集不能唯一标识，则称该属性组为候选码。比如学生实体中，“学号”是候选码，{姓名、班级}的组合可以唯一标识一个元组，但单独的姓名和班级无法唯一标识元组，因此姓名和班级的组合是一个候选码；
- 主码：主码也叫主键，主码是从候选码中选出来的。一个实体集只能有一个主码，但可以有多个候选码；
- 外码：外码也叫外键，如果一个关系中的一个属性是另一个关系中的主码，则这个属性为外码；
- 主属性：候选码中出现过的属性为主属性
- 非主属性：不包含在任何一个候选码中的属性称为非主属性

## 2.数据库范式

- 1NF
  - 属性不可再分，1NF是所有关系型数据库最基本的要求
  - 比如商品包含名称和数量两个属性，因此商品不能作为一个属性，应该将其分解为商品名称和商品数量两个属性
- 2NF
  - 在1NF的基础上，消除了**非主属性对码的部分函数依赖**，即所有的非主属性都完全的依赖于候选码
  - 一个典型的例子：学生的学号和课程号决定成绩，学号决定学院，学院决定宿舍，显然学生的学号和课程号是候选码，但是非主属性学院却不是完全依赖于候选码，因为单独的学号就可以决定学院，因此需要对表进行拆分
- 3NF
  - 在2NF的基础上，去除了**非主属性之间的传递函数依赖**
  - 比如上面例子中的学号决定学院、学院决定宿舍是不允许存在的
- BCNF
  - BC范式在第三范式的基础上，在某些**多个主属性**的情况下，去除了主属性之间的函数依赖

## 3.存储过程

- 存储过程是一些SQL语句的结合，中间加了一些逻辑控制语句；
- 存储过程在业务比较复杂时比较常用，此时可能需要很多的sql语句，将这些sql语句写成一个存储过程，方便下一次调用；
- 存储过程调试之后就可以稳定执行，效率较高；但存储过程难以调试和扩展，可移植性低。

```java
create procedure 过程名(参数列表)
begin
end
```

## 4.数据库设计的步骤

1. 需求分析：分析用户的需求
2. 概念结构设计：采用e-r模型进行设计，画出e-r图
3. 逻辑结构设计：将e-r图转换为表
4. 数据库实施：对数据库进行编程、测试和运行
5. 数据库的运行和维护

## 5.drop、delete、truncate

- drop table + 表名 直接将整个表删除 
- truncate table 表名 只删除表中的全部数据
- delete from 表名 +where 删除某一行或者多行的数据 

## 6.字符集

**乱码的本质**

- 编码和解码使用了不同或者不兼容的字符集

## 7.事务-ACID

>事务

事务是逻辑上的一组操作，要么都执行要么都不执行

>ACID

1.原子性

- 事务是最小的执行单位，不允许分割

2.一致性

- 事务执行前后，数据保持一致

3.隔离性

- 并发访问数据库时，一个事务不能被其他事务所干扰

4.持久性

- 一个事务提交之后，对数据库中数据的操作是持久的

# MySQL

## 1.索引

- 索引是一种快速查询和检索数据的数据结构，常见的索引结构：B树、B+树和Hash；索引就相当于目录的作用；

>优缺点

- 使用索引可以大大加快检索速度，通过创建**唯一性**的索引，可以保证数据库表中每一行数据的唯一性；
- 创建和维护索引耗费时间，且索引需要使用物理文件存储会耗费一定的空间

## 2.索引的底层数据结构

### 2.1 Hash 表

- 通过**哈希算法**，我们可以快速找到 value 对应的 index，找到了 index 也就找到了对应的 value。
- Hash冲突解决(**链地址法**)：多个key值最后的index值相同的情况下，使用链地址法来解决，将hash冲突的数据存放在链表中

>为什么mysql最终未选择hash作为其索引的数据结构呢

- hash冲突问题；
- hash不支持顺序和范围的查询，比如查找id小于50的所有元素，如果使用hash表的话，就是将1-49的id均进行hash计算，显然不合理。

### 2.2 B 树& B+树

- 目前大部分的数据库和文件系统都采用B树或者B+树作为索引结构
- Mysql的MyISAM和InnoDB引擎都是使用B+作为索引结构

>B树和B+树的不同

- B树的所有节点都存放key和data，B+树只有叶子节点存放key和data，其他节点只存放key；
- B树的叶子节点都是独立的，B+树的叶子节点有一条引用链指向与它相邻的叶子节点；
- B树的检索过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了；而B+树的检索效率很稳定，任何查找都是根节点到叶子节点的过程。

## 3. MyISAM 和 InnoDB

### 3.1 是否支持行级锁

- MyISAM 只有表级锁(table-level locking)，而 InnoDB 支持行级锁(row-level locking)和表级锁,默认为行级锁
- 也就说，MyISAM 一锁就是锁住了整张表，相对来讲InnoDB 在并发写的时候，性能会更优。

### 3.2 是否支持事务

- MyISAM 不提供事务支持。
- InnoDB 提供事务支持，具有提交(commit)和回滚(rollback)事务的能力。

### 3.3 是否支持外键

- MyISAM 不支持，而 InnoDB 支持。

### 3.4 是否支持数据库异常崩溃后的安全恢复

- MyISAM 不支持，而 InnoDB 支持。

使用 InnoDB 的数据库在异常崩溃后，数据库重新启动的时候会保证数据库恢复到崩溃前的状态。这个恢复的过程依赖于 `redo log` 。

🌈 拓展一下：

- MySQL InnoDB 引擎使用 **redo log(重做日志)** 保证事务的**持久性**，使用 **undo log(回滚日志)** 来保证事务的**原子性**。
- MySQL InnoDB 引擎通过 **锁机制**、**MVCC** 等手段来保证事务的隔离性（ 默认支持的隔离级别是 **`REPEATABLE-READ`** ）。
- 保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。

### 3.5 是否支持 MVCC

- MyISAM 不支持，而 InnoDB 支持
- MVCC 可以看作是行级锁的一个升级，可以有效减少加锁操作，提高性能。









