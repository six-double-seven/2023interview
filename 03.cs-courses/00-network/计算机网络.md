# 计算机网络

# 0. 常用词汇



| 符号 | 全称                   | 含义               | 备注                                                         |
| ---- | ---------------------- | ------------------ | ------------------------------------------------------------ |
| SYN  | SYNchronization        | 同步序号，建立联机 | tcp标志位                                                    |
| PSH  | push                   | 传送               | tcp标志位，为 1 时表示接收方应立即将数据交给上层             |
| RST  | ReSeT                  | 复位               | tcp标志位                                                    |
| FIN  | finish                 | 结束               | tcp标志位                                                    |
| URG  | urgent                 | 紧急               | tcp标志位，为 1 时表示存在紧急数据，紧急数据由紧急数据指针表示 |
| ACK  | Acknowledgement        | 确认               | tcp标志位，不同于ack                                         |
| ack  | Acknowledgement Number | 确认号             | 收到 seq=x 的数据包后回复 ack=x+1                            |
| MSS  | Maximum Segment Size   | 最大报文长度       |                                                              |

# 1. TCP/IP 5层体系结构

1.应用层(报文)

- 应用层位于传输层之上，为两个终端设备上`应用程序`之间的信息交换提供服务；
- 定义了数据交换的格式；

2.传输层

- 为两台终端设备`进程`之间的的通信提供服务；
- 典型的是TCP和UDP

3.网络层

- 为`分组交换网`上的不同主机提供通信服务，路由的选择；

4.链路层

- 将网络层传下来的ip数据报组装成帧，在相邻节点的链路上进行传输；

5.物理层

- 实现相邻计算机节点之间比特流的透明传输；
- **透明传输**：只传输数据而不对数据做任何的改变，且屏蔽了具体的传输介质和物理设备的差异；

# 2. 网络为什么分层

> 分层是为了 每一层只专注于做一类事情，比如使用框架开发一个后台应用程序，需要将系统大致分为三层：前后端交互的controller层、业务service层、数据库操作dao层，另外计算机整个体系从上到下都是按照严格的层次结构设计的。

- **各层之间相互独立**  每一层不需要关心其他层的具体实现，只需要知道自己如何调用底层提供的服务；

- **提高了整体灵活性**  只要保证提供的功能和暴露的接口没有发生改变，每一层都可以选择最合适的技术来实现，和开发中的 `高内聚 低耦合` 是一个道理。

  [高内聚 低耦合](https://www.cnblogs.com/xdecode/p/9393885.html)

  - **高内聚**   模块内部元素关联性越强，则内聚越高，每一个模块尽可能独立的完成某个功能；
  - **低耦合**   模块和模块之间关系越紧密，耦合越强，独立性越差；

- **大问题化小**  分层可以将复杂的网络问题分解为较小的、简单的问题来处理。

# 3.[浏览器中输入url到显示的过程](https://segmentfault.com/a/1190000006879700)

1. DNS解析
2. 建立TCP连接
3. 发送HTTP请求
4. 服务器处理请求并返回HTTP报文
5. 浏览器解析渲染页面
6. 连接结束

# 4.[Cookie和Session](https://blog.csdn.net/chen13333336677/article/details/100939030)

>Cookie

- 浏览器端第一次发送请求到服务器端
- 服务器端创建Cookie，该**Cookie中包含用户的信息**，然后将该Cookie发送到浏览器端
- 浏览器端再次访问服务器端时会携带服务器端创建的Cookie
- 服务器端通过Cookie中携带的数据区分不同的用户

![cokie](https://img-blog.csdnimg.cn/20190917204655188.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoZW4xMzMzMzMzNjY3Nw==,size_16,color_FFFFFF,t_7)

>Session

- 浏览器端第一次发送请求到服务器端，服务器端创建一个Session，同时会创建一个特殊的Cookie（name为JSESSIONID的固定值，value为session对象的ID），然后将该Cookie发送至浏览器端
- 浏览器端携带**Cookie**发送第N（N>1）次请求到服务器端，服务器端根据name为JSESSIONID的Cookie的value(sessionId)，去查询Session对象，从而区分不同用户

![Session](https://img-blog.csdnimg.cn/2019091720521815.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoZW4xMzMzMzMzNjY3Nw==,size_16,color_FFFFFF,t_70)

>Cookie && Session

**共同点**

- cookie和session都是用来跟踪浏览器用户身份的会话方式。

**不同点**

- **安全性：**Cookie数据保存在客户端且不安全，session数据保存在服务端是安全的。
- Cookie的sessionid是服务器和客户端建立连接时候随机分配的，如果浏览器使用的是cookie，那么所有数据都保存在浏览器端，只要不关闭浏览器，Cookie变量一直有效，保证长时间不掉线。但是cookie是不安全的，别人可能会分析存放在本地的cookie进行cookie欺骗
- 当登陆一个网站的时候，如果web服务器端使用的是**session**，那么所有的数据都保存在服务器上，客户端每次请求服务器的时候会发送当前会话sessionid，服务器根据当前sessionid判断相应的用户数据标志，以确定用户是否登陆或具有某种权限。由于数据存储在服务器上，是安全的。

# 5.URI和URL的区别

- uri  统一资源identifier标识符，可以唯一标识一个资源；
- url  统一资源 locator 定位符，可以提供该资源的路径，是一种具体的uri；

# 6.TCP和UDP区别

### 6.1 TCP

- TCP是面向连接可靠的数据服务，在数据传送之前要建立连接，数据传送之后要释放连接
- 数据传输之前通过三次握手建立连接，数据传递时有确认、重传、滑动窗口、拥塞控制机制，会增加需要开销，不仅使`协议数据单元`的头部增大，而且占用处理机的资源，因此一般用于文件的传输，邮件的发送和接收，远程登录等场景。

### 6.2 UDP

- udp是无连接不可靠的数据服务

- UDP传送数据之前不需要建立连接，
- 远地主机收到UDP报文后，不需要给出任何确认；
- 常应用于语音、视频、直播等

# 7.三次握手

### 7.1 步骤

1. 客户端向服务端发送带有`SYN`标志的数据包；第一次握手证明了server端接收正常；
2. 服务器向客户端发送带有`SYN/ACK`标志的数据包；第二次握手证明了client端发送和接收都正常；
3. 客户端向服务器端发送带有ACK的数据包；第三次握手证明了server端发送正常

**因此，三次握手就能确定双方收发功能都正常，缺一不可。** 

### 7.2 第二次握手传回了ACK，为什么还要传回SYN

- 传回ACK是为了告诉客户端，我收到了你发送的消息，表明client端到server端是正常的
- 回传SYN是为了建立从server端到client端的通信

# 8.四次挥手

![image-20220305170217368](http://six-double-seven.oss-cn-beijing.aliyuncs.com/img/image-20220306202023492.png)

1. client端发送FIN，关闭client到server的数据传送(lient：我说完了)
2. server端收到FIN，发回ACK(server：我知道你说完了)
3. server端继续发送其他消息，之后向client发送FIN(server：我也说完了)
4. client 端收到FIN，回复ack (client：知道了)

**至此，四次挥手关闭tcp连接**

# 9.TCP如何保证可靠传输

1. TCP给发送的每一个包标号，接收方对数据包进行排序，把有序的数据传送给应用层；

2. 检验和：如果收到的检验和有差错，将会丢弃该报文段且不确认收到；

3. **流量控制**：

   - 所谓流量控制是为了控制发送方的发送速率，保证接收方来得及接收，tcp通过`滑动窗口`实现流量控制；
   - tcp连接的每一方都有固定大小的缓冲空间，tcp的接收端只允许发送端发送接收端缓冲区可以容纳的数据，当接收方来不及处理发送方的数据，提示发送方降低速率，防止包丢失。
   - 接受方发送的确认报文中的`窗口字段`可以用来控制发送方窗口的大小，从而影响发送速率。窗口字段设置为0，则发送方不能发送数据

4. **拥塞控制：**

   - tcp的`发送方`要维持一个`拥塞窗口`的状态变量，拥塞窗口的大小取决于网络的拥塞程度，且动态变化；

   - 发送方的发送窗口是 `拥塞窗口` 和 接收方的`接收窗口` 中**较小**的一个；

   - **TCP拥塞控制的四种算法**

     慢开始、拥塞避免、快重传快恢复(FRR)。

5. ARQ(Automatic Repeat-reQuest)协议：

   - 自动重传请求
   - **基本原理**：每发完一个分组就停止发送，等待对方确认，收到确认之后再继续发送；

6. **超时重传**：当tcp发送一个报文段之后，启动定时器，等待目的端确认收到，在定时器的时间范围内未收到确认信号，将会重传。

# 10.应用层常见的协议

### 10.1 HTTP协议

- http主要是为web浏览器和web服务器之间的通信而设计的，当我们使用浏览器浏览网页，页面是通过HTTP请求进行加载的；
- Http是基于TCP协议的，因此在发送http请求之前需要建立TCP连接，经历3次握手。目前使用的http协议大多数是1.1，默认是开启keep-alive的，建立的连接可以在多次请求中被复用。

### 10.2 SMTP协议

- simple mail 简单邮件传输协议
- 只负责邮件的发送，负责接受的协议是`pop3/IMAP`

### 10.3 FTP

- 文件传输协议，基于TCP实现可靠的传输；
- **好处**：可以屏蔽操作系统和文件存储格式；
- FTP是基于客户-服务器(C/S)模型而设计，在客户端和FTP服务器之间建立两个连接。

### 10.4 Telnet

- 远程登录协议，通过终端登录到其他服务器；
- 建立在可靠的TCP之上，缺点是所有的数据(包括用户名和密码)均以明文发送，逐渐被SSH取代。

### 10.5 SSH

- ssh建立在tcp之上
- 相比于telnet，ssh协议会对传输的数据进行加密，保证数据的安全性

# 11. HTTP和HTTPS

## 11.1 HTTP协议通信过程

Http是应用层协议，以TCP作为底层协议，默认端口为`80`，通信的过程：

1. 服务器在80端口等待浏览器的请求；
2. 浏览器发起到服务器的TCP连接(创建套接字)；
3. 服务器接受来自浏览器的TCP连接；
4. 服务器和浏览器(HTTP客户端)之间通过套接字 **交换** HTTP消息；(是交换吗？在http协议里面客户端能发送消息，服务器端只能响应不能往回发消息？而TCP连接之后可以二者可以随便发消息，因此当应用层协议不能满足需求时，需要使用socket直接面对tcp进行编程)
5. 关闭TCP连接。

## 11.2 套接字socket

- 当应用层的协议不能满足具体的要求时，需要使用socket；
- socket可以脱离应用层直接和传输层打交道；例如 应用层相当于插座，应用层之下相当于电力系统，我们只需要将设备连接在插座上即可；
- socket用于连接上层应用和tcp层，使得我们自己的应用直接和tcp打交道

## 11.3 HTTP和HTTPS区别

- 端口号：HTTP默认端口是`80`，HTTPS默认端口是`443`

- 底层均是TCP ：HTTPS协议是基于HTTP的，使用TCP作为底层协议，是HTTP的加强安全版；

- 安全性：HTTPS的安全性更高

  (1)HTTP运行在TCP之上，所有的传输内容都是明文，客户端和服务器端都无法验证对方的身份

  (2)HTTPS是运行在SSL/TLS之上的HTTP协议，SSL/TLS运行在TCP之上。所有的传输内容都进行加密，采用对称加密，但对称加密的密钥是用`服务器方的证书`进行了非对称加密。

- 资源消耗：HTTPS的安全性更高，就意味着消耗更多的服务器资源。

# 12. SSL/TLS

1.**SSL** (Secure Sockets Layer) 安全套接字协议，**TLS**是基于SSL之上的

2.工作原理

- **非对称加密**

  SSL/TLS的核心要素是非对称加密，非对称加密采用两个密钥，一个公钥一个私钥，公钥由加密者(所有想与解密者通信的发送者)所有，私钥仅由解密者所有；

  ![image-20220306202023492](http://six-double-seven.oss-cn-beijing.aliyuncs.com/img/image-20220305170217368.png)

- **对称加密**

  - 由于SSL/TLS的非对称加密设计了较为复杂的数学算法，在实际通信的过程中，使用对称加密。
  - 对称解密：通信双方使用唯一密钥k且加密算法已知，加密方利用密钥k加密，解密方利用密钥k解密，保密性依赖于密钥k的保密性。

- **加密的流程**(1次非对称加密 + 多次对称加密)

  对称加密的安全性完全依赖于密钥k的安全性，在双方通信之前需要确定一个用于通信的密钥，而网络通信的信道是不安全的，传输报文对任何人都可见，因此需要使用非对称加密 对对称加密的密钥进行加密，这样就可以得到绝对安全的密钥。因此只需要一次非对称加密，交换对称加密的密钥，在之后的通信中，使用绝对安全的密钥对信息进行对称加密，确保准确性。

# 13. 对应用层的理解

(1) 应用层定义的是应用程序用于请求网络服务的**接口**，而不是指应用程序本身

(2) 我们所使用的软件是应用程序，只是一个**壳子**，而这些**软件里嵌套的协议**才是应用层的内容，使用网络的程序需要集成协议才可以正常使用；

(3) 比如打开IE浏览器，输入一个网址，就进入了相应的网站，那么这个IE浏览器就是我浏览网页的应用工具，也是工作在应用层的。**IE浏览器是基于HTTP协议开发的**，HTTP是一个应用层的协议。
