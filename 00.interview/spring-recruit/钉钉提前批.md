# 钉钉提前批一面

# 1.常见的数据结构，使用的场景

>综述

- 线性的数据结构：数组、链表、栈、队列
- 非线性的数据结构：树、堆、图

>数组

提供随机访问，但容量有限；

>链表

- 链表克服了数组需要预先知道长度的缺点，但是不具有数组随机读取的优点；
- 链表使用的是不连续的内存空间来存储数据，可以充分的利用计算机的内存空间；但链表不会节省空间，因为链表的每一个节点还要存放指向其他节点的指针；
- 链表的分类：单链表、双向链表、循环链表、双向循环链表

>数组和链表的应用场景

- 如果需要支持随机访问的话，选择数组链表无法做到
- 如果需要存储的数据元素的个数不确定，并且需要经常添加和删除的话，使用链表比较合适；
- 如果需要存储的数据元素个数确定，并且不需要经常添加和删除的话，使用数组比较合适；

>栈

- 栈是一种后进先出的数据结构
- 栈常用一维数组或者链表来实现，用数组实现的栈叫做**顺序栈**，用链表实现的栈叫做**链式栈**；

>栈的常见应用场景

- 实现浏览器的回退和前进功能

只需要两个栈S1和S2，比如顺序的查看了1 2 3 4 共4个页面，将4个页面压入S1中，此时如果想回退至2页面，就对栈S1进行弹栈，并将弹出来的元素压入栈S2中，此时S1自底向上为1和2 ，而栈S2中的元素自底向上是4 和 3；此后如果想要回退就对S1进行弹栈并压入S2中，如果想要前进就对S2进行弹栈并压入S1中以此类推；

- 检查符号是否成对出现

如果是左括号就直接压栈，如果不是左括号就与栈顶元素做比较，如果不相等就直接返回false；

- 反转字符串

将字符串中的每一个字符入栈再出栈即可反转；

- 维护函数的调用

最后一个被调用的函数必须先完成执行，符合栈的**后进先出**的特性；

>队列

- 队列是先进先出的线性表；通常用数组或者链表来实现，用数组实现的叫做**顺序队列**，用链表实现的叫做**链式队列**；

>队列的应用场景

当我们需要按照一定的顺序处理数据的时候，可以考虑使用队列这个数据结构；

- 消息队列

- **阻塞队列**   阻塞队列就是在队列的基础上增加了**阻塞操作**的队列，当队列为空的时候，出队操作阻塞；当队列满的时候，入队操作阻塞，使用阻塞队列可以实现 **生产者-消费者**模型；
- 线程池中的任务队列
- 播放器上的播放列表

>树

- 二叉树、满二叉树、完全二叉树、平衡二叉树(红黑树、AVL树)
- 存储有链式存储和顺序存储

>[树的应用场景](https://blog.csdn.net/qq_41475067/article/details/112794476)

- 哈夫曼树(**带权路径长度最小**的二叉树就称为哈夫曼树或最优二叉树) 

  哈夫曼编码是哈夫曼树在电讯通信中的应用之一，通常用二进制编码来表示字母或者其他字符；

- 文件系统的目录结构

- mysql的数据库索引

- xml、html的解析器需要用到树

>堆

- 堆中的每一个值都大于等于(小于等于)**子树中所有节点**的值；
- 堆和**有序数组**相比，堆的优势在于更新数据的效率较高；

>堆的应用场景

- 当我们只关心所有数据中的最大值和最小值，并且存在多次获取最大值和最小值、多次插入和删除数据时，就可以使用堆；
- 求数组中第k个最大元素

>图

- 图是一种非线性的数据结构，由顶点和边组成的集合是图
- 图的存储有邻接矩阵存储、邻接表存储；

>图的应用场景

- 地图中求最短路径

# 2.[MySQL索引为什么使用B+树而不是B树](https://www.jianshu.com/p/7ce804f97967)

- **B+树的磁盘读写代价更低**：B+树的内部节点并没有指向关键字具体信息的指针，因此其内部节点相对B树更小，一次性读入内存的关键字也就越多，则IO读写次数就降低了；
- **B+树的查询效率更加稳定**：由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路，所有关键字查询的路径长度相同，每一个数据的查询效率相当；
- **B+树更便于遍历**：由于B+树的数据都存储在叶子结点中，分支结点均为索引，只需要扫一遍叶子结点即可；
- **B+树更适合基于范围的查询**：B+树只需要去遍历叶子节点就可以实现整棵树的遍历，而且在数据库中基于范围的查询是非常频繁的；

# 3.虚拟内存

>什么是虚拟内存

- 通过虚拟内存，可以让程序拥有超过**系统物理内存**大小的可用内存空间；
- 另外虚拟内存为每个进程提供了一个一致的、私有的地址空间，每一个进程拥有一片连续完整的内存空间；
- **维基百科：**虚拟内存使得应用程序认为它拥有连续的可用的内存，而实际上通常被分割为多个物理内存碎片，还有一部分暂时存储在外部磁盘存储器上，在需要的时候进行数据交换；

>虚拟内存技术的实现

- **请求分页存储管理**：

  在作业运行的过程中发现要访问的页面不在内存，则由处理器通知操作系统按照对应的**页面置换算法**将相应的页面调入主存，同时操作系统也可以将暂时不用的页面置换到内存外；

- **请求分段存储管理**：

- **请求段页式存储管理**：

>页面置换算法

在地址映射的过程中，发现要访问的页面不在内存中，则发生**缺页中断**(就是访问的**页**不在内存中，需要操作系统将其调入主存中再进行访问)；当发生缺页中断的时，如果当前内存中并**没有空闲**的页面，操作系统就必须在内存中选择一个页面并将其移出内存，以便让出空间，用来淘汰哪一页的规则就叫做页面置换算法；

- OPT(最佳的页面置换算法)

  一般是用来衡量其他置换算法的方法；

- FIFO(先进先出置换算法)

  总是淘汰**最先进入内存**的页面；

- LRU(最久未使用置换算法)

  LRU算法赋予每个页面一个**访问字段**，用来记录该页面上次被访问所经历的时间T，淘汰T值最大的页面；

- LFU(最少使用置换算法)

  选择在之前时期**使用最少**的页面作为淘汰页；

# 4.进程和线程的区别

线程是进程划分成的更小的运行单位，一个进程在执行的过程中可以产生多个线程

- 进程之间往往是相互独立的，而线程之间往往相互依赖，比如在java中垃圾回收的线程存在于几乎所有的进程中；
- 线程的执行开销小，但不利于资源的管理和保护，进程相反

# 5.[并发场景下统计网页访问次数](https://juejin.cn/post/6844903760221700104)

由于要满足高并发，首先需要考虑用异步和缓存，所以考虑使用**多线程**加**Redis**的解决方案。

> 1.请求流程

1. 用户点击某篇文章详情页；
2. 前端发送一个`PUT`请求；
3. 后端使用**线程池**执行一个异步任务，立即返回给前端`200`响应；
4. 前端得到`200`响应后，立即把当前文章的浏览量+1。



![请求流程.png](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/1/13/16845107908c3bd6~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp)

> 2.后端主要逻辑

暂时把**增加的浏览量**（假设某篇文章为n）放进Redis里，然后**定期**刷新到Mysql数据库里，让这篇文章的浏览量在现有的基础上加n，然后把Redis中这篇文章的浏览量清零；

# 6.如何正确处理并发

> 1.系统扩容

系统扩容包括垂直扩容和水平扩容，增加设备和机器配置；

> 2.缓存

本地缓存或者集中式缓存，减少网络IO，基于内存读取数据;

>3.读写分离

采用读写分离，分而治之，增加机器的并行处理能力。

# 7.[ThreadLocal](https://www.jianshu.com/p/6fc3bba12f38)

>ThreadLocal是什么

ThreadLocal是解决线程安全问题一个很好的思路，它通过为每个线程提供一个独立的变量副本解决了变量并发访问的冲突问题。在很多情况下，ThreadLocal比直接使用synchronized同步机制解决线程安全问题更简单、更方便，且结果程序拥有更高的并发性。

>ThreadLocal的应用场景

在Java的多线程编程中，为保证多个线程对共享变量的安全访问，通常会使用synchronized来保证同一时刻只有一个线程对共享变量进行操作。这种情况下可以将**类变量**放到ThreadLocal类型的对象中，使变量在每个线程中都有**独立拷**贝，不会出现一个线程读取变量时而被另一个线程修改的现象。最常见的ThreadLocal使用场景是解决数据库连接、Session管理等。

# 8.[java线程通信和同步的方式](https://blog.csdn.net/a499957739/article/details/96286081)

- synchronized关键字修饰方法或代码段，实现数据的互斥访

- volatile修饰变量，实现多线程环境下数据的同步
- ReentrantLock可重入锁，实现数据的互斥访问
- synchronized结合Object的wait和notify方法，实现线程间的等待通知机制
- ReentrantLock结合Condition接口的await()和signal()方法，实现线程间的等待通知机制   

# 9.Spring的AOP实现原理，为什么与三级缓存有联系

>三级缓存

```java
//一级缓存，用来存放初始化完成的单例bean
Map<String, Object> singletonObjects;
//二级缓存，用来存放提前暴露的原始bean
Map<String, Object> earlySingletonObjects;
//三级缓存，用来存放 “包装提前暴露的原始bean”的ObjectFactory对象
Map<String, ObjectFactory<?>> singletonFactories;
```

>循环依赖和三级缓存

解决循环依赖的核心，不在乎几级缓存，而在于提前暴露引用地址；

>AOP和三级缓存

- 三级缓存感觉为了延迟调用aop逻辑；

- 既然尚未初始化完成的bean都可以提前注入到其他bean里面，为啥就不能提前AOP呢？我们用的是bean的引用，只要这个引用不变，至于引用所指向的对象啥时候初始化完，其实无所谓。其他bean也只是持有的是这个bean的引用，同理AOP代理也是仅仅持有target bean的引用。所以，所有使用到bean的地方，只要实例化完成生成了引用地址，只要这个地址不变，就可以把这个bean当做成熟的bean使用。等整个容器启动完成，这些bean自然而然的就初始化好了，所有引用这个bean的Bean也自然而然的就可以使用了；

# 10.full GC

>什么是full GC

Full GC是一次特殊GC行为的描述，这次GC会回收**整个堆的内存**，包含老年代，新生代；

> 如何排查full GC



> full GC存在的原因

- **System.gc()方法的调用**

  此方法的调用是建议JVM进行Full GC,虽然只是建议而非一定,但很多情况下它会触发 Full GC,从而增加Full GC的频率,也即增加了间歇性停顿的次数。
