# 自我介绍

​	hello 下午好 ！很荣幸能够参加本次面试，我是neu23届毕业生lqq，大学的两年综测排名，拿到了4份奖学金和相关科技竞赛的奖项。目前在京东零售实习，主要负责京东零售两个项目的开发和维护。在上次面试时有了解到咱们部门更偏向于前端，虽然目前我实习的岗位是java开发岗，但我此前有3个和前端相关的项目经历

- 第一个是21年6月份暑期实训项目“云工厂管理系统”，该系统是springboot+vue+Element-ui的一个前后端分离的web网站；
- 第二个是使用微软的xarmarin.forms开发的饮食推荐的app，其中使用到了MVVM架构以及依赖注入和数据绑定的思想
- 第三个是使用安卓的Activity组件访问web接口实现的天气预报app

以上三个项目均在我的gitee上面进行了开源

- 另外会定期的通过博客整理并分享自己的所学知识，比如之前学习微软的xamarin.Forms跨平台开发技术、以及近期刷的算法题、实际项目开发中具体问题的解决 ，我都会整理并分享在博客上，用来记录自己的点点滴滴。
- 最后的我想说的是虽然我现在实习的岗位更偏向于后端一点，但是个人认为整个互联网行业都是互通的，基本思想都是一致的。
  - 比如说java类、Vue实例、Activity的生命周期是类似的，都是为程序的开发人员提供一些添加自己代码的时机
  - vue实例对象中的属性和方法也可以类比于java对象的属性和方法
  - 再比如java的spring框架和微软的xamarin.forms里面都有使用到依赖注入这种思想，将对象的创建交给第三方来管理
- 因此呢后端的一些开发经验和java基础也希望能够为为未来的前端工作能有所帮助
- 好的以上是我的一个简短的自我介绍，期待着能够加入到美团这个大家庭中，蟹蟹！

# 最后提问

- 坦白地讲呢我对自己今天的面试表现不是非常满意，还可以表现得更好，但是我还是非常想得到这个机会，您能否给我一些建议
- 不管怎么样，还是得感谢您给的机会，让我自己认识到自己的不足，坦白地说我离这个岗位的要求还有些距离，但是我想知道，如果将来我还想来面试咱们公司这个岗位的话，您能否给一些具体的建议。
- 我想请问的是我目前面试的岗位未来的发展规划或职业发展路径是怎样的？

# 1.谈谈你对 MVVM 的理解

MVVM 是 Model-View-ViewModel 的缩写，其中：

- Model 代表数据模型，可以在 Model 中定义数据修改和操作的业务逻辑。可以把 Model 称为数据层，因为它仅仅关注数据本身，不关心其他行为。
- View 是视图层，当 ViewModel 对 Model 进行更新的时候，会通过数据绑定更新到 View层
- ViewModel 称为业务逻辑层，是数据层和视图层通信的桥梁。View 需要什么数据，ViewModel 要提供这个数据，有些操作也需要 ViewModel 的响应。

【总结】：

- MVVM 模式简化了界面与业务的依赖，解决了数据频繁更新。在 MVVM 中，利用双向绑定技术，使得 Model 变化时，ViewModel 会自动更新，而 ViewModel 变化时，View 也会自动更新。
- MVVM主要解决了MVC中大量的dom操作使页面渲染性能降低，加载速度变慢，影响用户体验等问题

# 2. [跨域问题](https://zhuanlan.zhihu.com/p/425855609)

>浏览器的同源策略

- 所谓同源（即指在同一个域）就是两个页面具有相同的协议（protocol），主机（host）和端口号（port）；
- 同源策略（Sameoriginpolicy）是一种约定，它是浏览器最核心也最基本的安全功能；

> 为什么会出现跨域问题

- 浏览器从一个域名的网页去请求另一个域名的资源时，协议、主机、端口有一个不同，都是跨域。
- 在前后端分离的模式下，前后端的域名是不一致的，此时就会发生跨域访问问题。

>解决

- 在云工厂的项目里使用的是**代理**实现跨域问题的解决，只要扫描到/api就跳转至后端ip加端口

- JSONP跨域请求数据

  由于`<script>`可以对跨域资源进行请求，于是可以对`DOM`动态地`append`一个`<script>`并添加`src`且携带一个`callback`函数名,待请求完成后调用`callback`。

>JSONP的产生

- AJAX直接请求普通文件存在跨域无权限访问的问题，不管是静态页面、动态网页、web服务只要是跨域请求，一律不准；
- 但是**Web页面上调用js文件时则不受是否跨域的影响**（不仅如此，我们还发现凡是拥有`src`这个属性的标签都拥有跨域的能力，比如`<script>`、`<img>`、`<iframe>`)；
- 因此通过添加一个< script>标签，并添加src属性
- JSONP协议允许用户传递一个`callback`参数给服务端，然后服务端返回数据时会将这个`callback`参数作为函数名来包裹住JSON数据，这样客户端就可以随意定制自己的函数来自动处理返回数据了。

```javascript
//前端
function jsonpHandle(data){console.log(data);} //首先定义函数，请求完成后会携带参数调用函数
var url = "http://127.0.0.1/test.php?callback=jsonpHandle";
var obj = $('<script><\/script>');
obj.attr("src",url);
$("body").append(obj); // 动态地添加一个script
```

# 3. 对SPA的理解

- **SPA**全称是 **single page application**  单页面应用
- 在传统的网站中，不同的页面之间的切换都是直接从服务器加载一整个新的页面，而在SPA这个模型中，每次只需要重写页面发生变化的部分，从而避免了过多的数据交换，响应速度自然相对会提高；
- 假如使用SPA，在进行页面切换的过程中，导航栏一般来讲是不会发生变化的，因此使用SPA会使得页面之间的切换非常快，在一定程度上也减少了后端服务器的压力

# 4. 谈谈你对响应式的理解

- 通过数据模型（普通的 JS 对象）来驱动视图的更新，就是响应式。
- 以vue的实例对象data 选项为例，当我们把一个普通的 JS 对象传入 Vue 实例作为 data 时，Vue 将遍历这个对象的所有属性，定义属性的 getter和 setter ，从而让 Vue 能够追踪感知到这些属性访问与修改，当依赖的 setter 触发时，就会通知 watcher ，从而使他们关联的组件重新渲染。

# 5. 微前端

**前言**

在软件开发中，逐渐出现了类，模块化，组件化，设计模式等来解耦和拆分我们的代码，使得代码更易读，易维护。而微前端架构其实也是一种新的思想来帮助我们更好的拆分一些现在方式无法解决的问题而已。

**什么是微前端**

- 微服务的架构思想在前端的映射和落地
- 针对复杂且大型的web前端的整体架构和组织结构问题，将单体的前端拆分成更小，更简单的模块，使其可以独立开发，测试和部署，最后将其整合到一起。

>Vue

# 6. Vue简述

- 响应式的数据绑定

  ​	Vue 使用了MVVM架构，支持双向的数据绑定，数据变化更新视图，视图变化更新数据，很典型的例子是输入框的内容发生变化时，data 中对应的数据同步变化，data 中绑定的数据变化时，输入框的内容同步变化。

- 组件化开发

  - Vue.js通过组件，把一个单页应用中的各种模块拆分到一个一个单独的组件（component）中
  - 只需要在父级应用中写好各种组件标签（占坑），并且在组件标签中写好要传入组件的参数（就像给函数传入参数一样，这个参数叫做组件的属性）
  - 最后再分别对各种组件进行实现（填坑）。
  - 比如在写云工厂项目的过程中，对整个页面进行了一个划分包括头部、侧边栏、底部以及中心内容等几大区域，对每一个部分分别进行开发最后import至一个页面中即可

- Virtual DOM

  - 所谓Virtual DOM 是一种可以**预先**通过JavaScript进行各种计算，把最终的DOM操作计算出来并优化，由于这个DOM操作属于预处理操作，并没有真实的操作DOM，所以叫做虚拟DOM。最后在计算完毕才真正将DOM操作提交，将DOM操作变化反映到DOM树上

# 7. Vue、Activity的生命周期

## 7.1 Vue

>简介

​	Vue实例从创建到销毁的过程就是生命周期，指的是从创建、初始化数据、编译模板、挂载Dom到渲染、更新到渲染、销毁等一系列过程，主要分为以下8个阶段：创建前后、载入前后、更新前后、销毁前后以及一些特殊场景的生命周期，其中钩子就是给了开发人员在不同阶段添加自己代码的机会。

>8个阶段

- 创建前/后： 
  - 在beforeCreated阶段，vue实例的挂载元素`$el`和数据对象data都为undefined，还未初始化。
  - created阶段，vue实例的数据对象data有了，`$el`还没有。
- 载入前/后：
  - 在beforeMount阶段，vue实例的`$el`和data都初始化了，但还是挂载之前为虚拟的dom节点data.message还未替换。
  - 在mounted阶段，vue实例挂载完成，data.message成功渲染。

- 更新前/后：当data变化时，会触发beforeUpdate和updated方法。
- 销毁前/后：在执行destroy方法后，对data的改变不会再触发周期函数，说明此时vue实例已经解除了事件监听以及和dom的绑定，但是dom结构依然存在。

>created和mounted 

- created 是在组件实例一旦创建完成的时候，立刻调用这时候的页面，dom节点未生成
- mounted 是在页面dom节点渲染完毕之后再执行，created比mounted的触发时机更早一些

## 7.2 Activity

> 创建阶段

- onCreate()  

  在onCreate()方法里执行最基本应用启动逻辑，该逻辑在 Activity 的整个生命周期中只发生一次。方法执行之后进入到“已开始”状态。

- onStart()

  当Activity 进入“已开始”状态时，系统会调用onStart()函数，使 Activity 对用户可见但此时无法进行交互onStart() 方法会非常快速地完成，一旦此回调结束，Activity 便会进入“已恢复”状态；

- onResume()

  调用onResume()方法之后，页面可见且支持交互，应用会一直保持这种状态，而此前的创建和开始的过程是非常短暂的。

> 运行阶段

- 执行相关代码逻辑

> 结束阶段

- onPause()

  调用onPause()方法之后，页面无法进行交互；

- onStop()

  调用onStop()方法之后，页面不可见；

- onDestroy()

  调用onDestroy()方法之后，页面彻底被销毁

![activity_lifecycle-2](http://six-double-seven.oss-cn-beijing.aliyuncs.com/img/activity_lifecycle-2.png)

# 8. Vue 双向数据绑定

>简介

- Vue 双向数据绑定是指：数据变化更新视图，视图变化更新数据，很典型的例子是输入框的内容发生变化时，data 中对应的数据同步变化，data 中绑定的数据变化时，输入框的内容同步变化。

> 具体实现

- 订阅器 Dep ：扮演的是观察目标的角色，每一个数据都会有Dep的实例，当本数据变更时，会调用notify方法通知监听器 Observer

- 监听器 Observer ：对数据对象进行遍历，利用 Object.defineProperty() 在属性上都加上 getter 和 setter ，从而监听数据的变化。
- 订阅者 Watcher ：订阅者是监听器和解析器之间通信的桥梁，主要任务是订阅监听器中的属性值变化的消息，当收到属性值变化的消息时，触发解析器中对应的更新函数。

- 解析器 Compile ：解析模板指令，将模板中的变量都替换成数据，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变化就会调用更新函数进行更新。

#  9. Vue的异步渲染

- 如果不采用异步渲染，那么每次更新数据都会进行重新渲染，这会对性能大打折扣，异步渲染是提高性能的手段之一。
- 只要监听到数据变化，Vue 将开启一个队列，并缓冲在同一个事件循环中发生的所有数据变更。如果同一个 watcher 被多次触发，只会被推入到队列中一次。然后，在下一个事件循环中，Vue 刷新队列并执行实际工作，即进行渲染

# 10. v-if 和 v-show

**共同点：** 都能控制元素的显示和隐藏；

**不同点：** 

- `v-show` 本质就是通过控制 css 中的 `display` 设置为 `none`，控制隐藏，只会编译一次；
- `v-if` 是动态的向 DOM 树内添加或者删除 DOM 元素，若初始值为 `false` ，就不会编译了，另外 `v-if` 不停的销毁和创建会比较消耗性能。

【总结】如果要频繁切换某节点，使用 `v-show` (切换开销比较小，初始开销较大)。如果不需要频繁切换某节点使用 `v-if`（初始渲染开销较小，切换开销比较大）

# 11. V-model的使用

`v-model` 用于表单数据的双向绑定，其实它就是一个语法糖，这个背后就做了两个操作：

- `v-bind` 绑定一个 `value` 属性
- `v-on` 指令给当前元素绑定 `input` 事件

# 12. Vue定义router 

- 在router目录下的index.js文件中，定义路由并引入对应的页面

>Axios

# 13. Axios

Axios 是一个基于 promise 的网络请求库，可以用于浏览器和 node.js

- 从浏览器创建 [XMLHttpRequests](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest)
- 从 node.js 创建 [http](http://nodejs.org/api/http.html) 请求

```java
import axios from "axios";
axios.get('/users')
  .then(res => {
    console.log(res.data);
  }).catch(xxx);
```

- 支持 [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) API
- 支持拦截请求和响应
- 支持转换请求和响应数据

>JS

# 14. JS使用的基本规范

- 使用 ===或!==来比较true/false或者数值
- switch必须带有default分支
- 函数应该有返回值 
- 命名要有意义，使用驼峰命名法

# 15. Ajax使用

>介绍

- 全称： Asynchronous Javascript And XML
- 所谓异步，就是向服务器发送请求的时候，我们不必等待结果，而是可以同时做其他的事情，等到有了结果它自己会根据设定进行后续操作，与此同时，页面是不会发生整页刷新的，提高了用户体验。 

> 创建Ajax的过程 

-  创建XMLHttpRequest对象（异步调用对象）

```javascript
var xhr = new XMLHttpRequest();
```

- 创建新的Http请求（方法、URL、是否异步）

```javascript
xhr.open(‘get’,’example.php’,false);
```

-  设置响应HTTP请求状态变化的函数。 

```java
 xmlhttp.onreadystatechange=httpStateChange;//设置HTTP请求状态变化的函数
```

- 发送http请求

```javascript
xhr.send(data);
```

-  获取异步调用返回的数据，该步骤需要注意一下问题：
  - 页面初次加载时，尽量在web服务器一次性输出所有相关的数据，只在页面加载完成之后，用户进行操作时采用ajax进行交互;
  - 同步ajax在IE上会产生页面假死的问题。所以建议采用异步ajax。 
  - 尽量减少ajax请求次数 
  - ajax安全问题，对于敏感数据在服务器端处理，避免在客户端处理过滤。对于关键业务逻辑代码也必须放在服务器端处理。

# 16. XML与JSON的区别

- 数据体积方面。JSON相对于XML来讲，数据的体积小，传递的速度更快些。
- 数据交互方面。JSON与JavaScript的交互更加方便，更容易解析处理，更好的数据交互。
- 数据描述方面。JSON对数据的描述性比XML较差。
- 传输速度方面。JSON的速度要远远快于XML。

# 17. JS垃圾回收机制

- 标记清除： 这个算法把“对象是否不再需要”简化定义为“对象是否可以获得”。 这个算法假定设置一个叫做根（root）的对象（在Javascript里，根是全局对象）。定期的，垃圾回收器将从根开始，找所有从根开始引用的对象，然后找这些对象引用的对象。从根开始，垃圾回收器将找到所有可以获得的对象和所有不能获得的对象。
- 引用计数： 这是最简单的垃圾收集算法。此算法把“对象是否不再需要”简化定义为“对象有没有其他对象引用到它”。如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收。 该算法有个限制：无法处理循环引用。两个对象被创建，并互相引用，形成了一个循环。它们被调用之后不会离开函数作用域，所以它们已经没有用了，可以被回收了。然而，引用计数算法考虑到它们互相都有至少一次引用，所以它们不会被回收。



# 8. http的状态码

- 响应分为以下5类

| 分类 | 分类描述                                       |
| :--- | :--------------------------------------------- |
| 1**  | 信息，服务器收到请求，需要请求者继续执行操作   |
| 2**  | 成功，操作被成功接收并处理                     |
| 3**  | 重定向，需要进一步的操作以完成请求             |
| 4**  | 客户端错误，请求包含语法错误或无法完成请求     |
| 5**  | 服务器错误，服务器在处理请求的过程中发生了错误 |

- 状态码列表

| 状态码 | 状态码英文名称                  | 中文描述                                                     |
| :----- | :------------------------------ | :----------------------------------------------------------- |
| 100    | Continue                        | 继续。客户端应继续其请求                                     |
| 101    | Switching Protocols             | 切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议 |
| 200    | OK                              | 请求成功。一般用于GET与POST请求                              |
| 201    | Created                         | 已创建。成功请求并创建了新的资源                             |
| 202    | Accepted                        | 已接受。已经接受请求，但未处理完成                           |
| 203    | Non-Authoritative Information   | 非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本 |
| 204    | No Content                      | 无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档 |
| 205    | Reset Content                   | 重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域 |
| 206    | Partial Content                 | 部分内容。服务器成功处理了部分GET请求                        |
| 300    | Multiple Choices                | 多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择 |
| 301    | Moved Permanently               | 永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替 |
| 302    | Found                           | 临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI |
| 303    | See Other                       | 查看其它地址。与301类似。使用GET和POST请求查看               |
| 304    | Not Modified                    | 未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源 |
| 305    | Use Proxy                       | 使用代理。所请求的资源必须通过代理访问                       |
| 306    | Unused                          | 已经被废弃的HTTP状态码                                       |
| 307    | Temporary Redirect              | 临时重定向。与302类似。使用GET请求重定向                     |
| 400    | Bad Request                     | 客户端请求的语法错误，服务器无法理解                         |
| 401    | Unauthorized                    | 请求要求用户的身份认证                                       |
| 402    | Payment Required                | 保留，将来使用                                               |
| 403    | Forbidden                       | 服务器理解请求客户端的请求，但是拒绝执行此请求               |
| 404    | Not Found                       | 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置"您所请求的资源无法找到"的个性页面 |
| 405    | Method Not Allowed              | 客户端请求中的方法被禁止                                     |
| 406    | Not Acceptable                  | 服务器无法根据客户端请求的内容特性完成请求                   |
| 407    | Proxy Authentication Required   | 请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权 |
| 408    | Request Time-out                | 服务器等待客户端发送的请求时间过长，超时                     |
| 409    | Conflict                        | 服务器完成客户端的 PUT 请求时可能返回此代码，服务器处理请求时发生了冲突 |
| 410    | Gone                            | 客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置 |
| 411    | Length Required                 | 服务器无法处理客户端发送的不带Content-Length的请求信息       |
| 412    | Precondition Failed             | 客户端请求信息的先决条件错误                                 |
| 413    | Request Entity Too Large        | 由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息 |
| 414    | Request-URI Too Large           | 请求的URI过长（URI通常为网址），服务器无法处理               |
| 415    | Unsupported Media Type          | 服务器无法处理请求附带的媒体格式                             |
| 416    | Requested range not satisfiable | 客户端请求的范围无效                                         |
| 417    | Expectation Failed              | 服务器无法满足Expect的请求头信息                             |
| 500    | Internal Server Error           | 服务器内部错误，无法完成请求                                 |
| 501    | Not Implemented                 | 服务器不支持请求的功能，无法完成请求                         |
| 502    | Bad Gateway                     | 作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应 |
| 503    | Service Unavailable             | 由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中 |
| 504    | Gateway Time-out                | 充当网关或代理的服务器，未及时从远端服务器获取请求           |
| 505    | HTTP Version not supported      | 服务器不支持请求的HTTP协议的版本，无法完成处理               |
