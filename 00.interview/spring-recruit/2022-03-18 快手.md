# 2022-03-18 快手

# 1.java的基本数据类型

byte(1)、short(2)、int(4)、long(8)、float(4)、double(8)、char(2)、boolean(1);

# 2.[Integer和int](https://www.cnblogs.com/guodongdidi/p/6953217.html#:~:text=%EE%80%80int%E5%92%8CInteger%E7%9A%84%E5%8C%BA%E5%88%AB%EE%80%81%201%E3%80%81%EE%80%80Integer%E6%98%AFint%EE%80%81%E7%9A%84%E5%8C%85%E8%A3%85%E7%B1%BB%EF%BC%8C%EE%80%80int%EE%80%81%E5%88%99%E6%98%AFjava%E7%9A%84%E4%B8%80%E7%A7%8D%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B,2%E3%80%81%EE%80%80Integer%EE%80%81%E5%8F%98%E9%87%8F%E5%BF%85%E9%A1%BB%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%90%8E%E6%89%8D%E8%83%BD%E4%BD%BF%E7%94%A8%EF%BC%8C%E8%80%8C%EE%80%80int%EE%80%81%E5%8F%98%E9%87%8F%E4%B8%8D%E9%9C%80%E8%A6%81%203%E3%80%81%EE%80%80Integer%EE%80%81%E5%AE%9E%E9%99%85%E6%98%AF%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BC%95%E7%94%A8%EF%BC%8C%E5%BD%93new%E4%B8%80%E4%B8%AA%EE%80%80Integer%EE%80%81%E6%97%B6%EF%BC%8C%E5%AE%9E%E9%99%85%E4%B8%8A%E6%98%AF%E7%94%9F%E6%88%90%E4%B8%80%E4%B8%AA%E6%8C%87%E9%92%88%E6%8C%87%E5%90%91%E6%AD%A4%E5%AF%B9%E8%B1%A1%EF%BC%9B%E8%80%8C%EE%80%80int%EE%80%81%E5%88%99%E6%98%AF%E7%9B%B4%E6%8E%A5%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE%E5%80%BC)

- Integer是int的包装类，int则是java的一种基本数据类型；

- Integer实际是对象的引用，当new一个Integer时，实际上是生成一个指针指向此对象；而int则是直接存储数据值 ；
- Integer的默认值是null，int的默认值是0；
- Integer变量必须实例化后才能使用，而int变量不需要 

>应用场景

- Integer可以区分出**未赋值**和**值为0**的区别，int则无法表达出未赋值的情况，例如，要想表达出没有参加考试和考试成绩为0的区别，则只能使用Integer
- 在JSP开发中，Integer的默认为null，所以用el表达式在文本框中显示时，值为**空白字符串**，而int默认的默认值为0，所以用el表达式在文本框中显示时结果为0，所以**int不适合作为web层的表单数据的类型**；
- Integer提供了多个与整数相关的操作方法，比如将一个字符串转换成整数，另外Integer中还定义了表示整数的最大值和最小值的常量。

# 3.[抽象类和接口](https://www.jianshu.com/p/038f0b356e9a)

```java
public interface Person{
  public static final int a=10;
  //JDK1.8
    default void sayHello(){
        System.out.println("Hello World");
    }
    public void say();
}
public abstract class Person{
  public abstract void say();
  public void eat(){};
}
```

>抽象类

- 使用**abstract**关键字修饰的类就是抽象类，如果一个类没有包含足够多的信息来描述一个具体的对象，这样的类就是抽象类；
- 一个抽象类不能实例化，因为“没有包含足够多的信息来描述一个具体的对象”。但终归属于类，所以仍然拥有普通类一样的定义。依然可以在类的实体定义成员变量，成员方法，构造方法等；
- **抽象方法**：抽象方法：只声明，不实现。具体的实现由继承它的子类来实现。被abstract修饰的方法，只有方法名没有方法实现，具体的实现要由子类实现。方法名后面直接跟一个分号，而不是花括号；
- 包含抽象方法的一定是抽象类，但是抽象类不一定含有抽象方法，**抽象类里面可以有非抽象方法**；

>接口

- **接口**  是**抽象方法的集合**。接口是个集合，并不是类，类描述了属性和方法，而接口只包含方法(未实现的方法)，虽然接口内的方法都是抽象的(**jdk1.8后可以有一个默认的实现**)但是不需要abstract关键字；
- 接口可以被实现，实现某个接口的类必须在类中实现该接口的全部方法；
- 接口中没有构造方法（因为接口不是类)、接口中的方法必须是抽象的（**jdk1.8后可以有一个默认的实现**) 、接口中除了static、final变量，不能有其他变量；
- 接口支持多继承（一个类可以实现多个接口）

>抽象类和接口的相同点

- 都不能被实例化
- 接口的实现类或者抽象类的子类只有实现了全部方法后才能实例化

>抽象类和接口的不同点

**1.实现不用**

- 抽象类使用extends关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现；
- 子类使用关键字implements来实现接口。它需要提供接口中所有声明的方法的实现。

**2.构造器**

- 抽象类终究是属于类，包括类的构造方法，也就是构造器。
- 但是接口是所有抽象方法的集合，是集合不是类。当然没有构造方法一说，更别提什么构造器了；

**3.修饰符**

- 抽象类中的抽象方法可以有public、protected这些修饰符；
- 而接口方法默认修饰符是public，也可以使用protected修饰符；

**4.** 接口只有定义，一般是没有方法的实现，1.8以后有默认的default方法体；

    抽象类可以有定义和实现，方法可在抽象类中实现；

**5. **抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 **public static final** 类型的；

>为什么接口中的成员变量只能是 **public static final** 类型的；

- 如果不是static的话，某一个类C实现接口A和接口B，而接口A和B中均有成员变量a且二者值不同，那么C中的变量a的取值就出现了问题，因此接口中的成员变量必须是static；
- 如果不是final的话，在每一个实现类中都可以进行修改，那么和抽象类的属性没有区别；

> 什么时候用抽象类 什么时候用接口

- **需要多继承** 只能选择接口，接口是可以实现多继承的 而抽象类不可以；

# 4.static && 静态方法

>为什么使用静态方法

- 静态方法的好处就是不用生成类的实例就可以直接调用。
- [static]方法修饰的成员不再属于某个对象，而是属于它所在的类。只需要通过其类名就可以访问，不需要再消耗资源反复创建对象。
- 在类第一次加载的时候，static就已经在[内存]中了，直到程序结束后，该内存才会释放。

>什么时候使用static

如果这个方法是作为一个工具来使用的，就声明为static；

# 5.[线程](https://blog.csdn.net/qq_52641681/article/details/120629350?spm=1001.2014.3001.5501)

>什么是线程安全

 线程安全就是多线程访问时，采用了加锁机制，当一个线程访问该类的某个数据时，进行保护，其他线程不能进行访问直到该线程读取完，其他线程才可使用。不会出现数据不一致或者数据污染。

> 如何创建线程

- 继承Thread，重写Run();
- 实现Runnable
- 匿名内部类

>run()和start()的区别

- start()方法的作用是启动一个**分支线程**，在JVM中开辟一个新的栈空间，这段代码的任务只是为了开启一个新的栈空间，只要新的栈空间开出来，start()方法就结束了，代表这线程启动成功；
- 线程启动成功之后会自动调用run()方法，并且run()方法在分支栈的栈底部;
- 如果不执行start()方法，直接调用run()方法的话实际上并没有开启线程，只是普通的方法调用;

>调用start()方法会立刻执行吗？

不会立刻执行，调用start()方法只是将状态更新为ready状态，还需等待时间片；

>终止线程

- 强行终止线程的执行:  **stop()** ;
- 合理终止线程的执行: 通过修改`boolean`类型的`run`来结束线程;
- **interrupt()**  不能中断在运行中的线程，它只能改变**中断状态**而已

# 6.Linux命令

>查找特定字符

**grep** 命令    `grep "t" test.txt`  

>查看文本文件的前10行

**head**(查看前2行 `haed -n 2 test.txt`)、**tail**(查看末尾几行)

# 7.乐观锁和悲观锁

乐观锁和悲观锁是两种思想，用于解决并发场景下的数据竞争问题。

- 乐观锁：乐观锁在操作数据时非常乐观，认为别人不会同时修改数据。因此乐观锁不会上锁，只是在执行更新的时候判断一下在此期间别人是否修改了数据：如果别人修改了数据则放弃操作，否则执行操作。
- 悲观锁：悲观锁在操作数据时比较悲观，认为别人会同时修改数据。因此操作数据时直接把数据锁住，直到操作完成后才会释放锁；上锁期间其他人不能修改数据。
