# 2022-3-21 美团

## 1.[HashMap的冲突解决](https://blog.csdn.net/mashaokang1314/article/details/88672035)

>java中hashmap的冲突解决使用的是拉链法

>1.开放地址法

- 线性探测再散列

  放入元素，如果发生冲突，就往后找没有元素的位置；

- 平方探测再散列

  如果发生冲突，放到(冲突+1^2)位置；如果还冲突，则放到(冲突-1^2)位置；

  如果还冲突，则放到(冲突+2^2)位置；如果还冲突，则放到(冲突-2^2)位置；

  按照 +1^2、-1^2、+2^2、-2^2、+3^2、-3^2依次类推

- 伪随机探测

  按顺序决定哈希值时，如果某数据已经存在则通过随机函数随机生成一个数，在原来哈希值的基础上加上随机数，直至不发生哈希冲突；

- 缺点
  - 扩容成本较高、使用探测序列造成额外计算时间
  - 删除的时候需要设置**删除标记**、造成额外的空间和操作

>2.拉链法(hashmap使用拉链法)

- 如果发生冲突，就在冲突位置连接生成链表；
- **优点**
  - 对于记录总数频繁可变的情况处理的较好；
  - 删除记录时只需要通过指针操作即可；
  - 节点是动态分配的，不会造成内存的浪费；

>3.再哈希

如果发生冲突，就用另一个方法计算hashcode，两次结果值不一样就不会发生[hash]冲突。

## 2.hashmap的底层实现

- JDK7中HashMap采用的是位桶+链表的方式，即我们常说的散列链表的方式，而 JDK8中采用的是位桶+链表/红黑树;
- 链表来存储hash值一样的key-value. 如果按照链表的方式存储，随着节点的增加数据会越来越多，这会导致查询节点的时间复杂度会逐渐增加，平均时间复杂度Ｏ(n)。 为了提高查询效率，故在JDK１.8中引入了改进方法红黑树。此数据结构的平均查询效率为Ｏ(long n);

## 3.ConcurrentHashMap

>简介

DK8中ConcurrentHashMap参考了JDK8 HashMap的实现，采用了**数组+链表+红黑树**的实现方式来设计，内部大量采用**CAS**操作;

Java8 ConcurrentHashMap结构基本上和Java8的HashMap一样，但保证**线程安全**性；

>CAS操作

CAS是compare and swap的缩写，即我们所说的比较交换。CAS是一种基于锁的操作，而且是**乐观锁**；

在java中锁分为**乐观锁**和**悲观锁**，悲观锁是将资源锁住，等上一个线程释放锁之后，下一个线程才可以访问；

而乐观锁采取了一种宽泛的态度，通过某种方式不加锁来处理资源，比如通过给记录加version来获取数据，性能较悲观锁有很大的提高。 

## 4.java中的锁

## 5.[输入域名到展示的过程](https://segmentfault.com/a/1190000006879700)

- DNS 解析
- TCP 连接
- 发送 HTTP 请求
- 服务器处理请求并返回 HTTP 报文
- 浏览器解析渲染页面
- 连接结束

## 6.[防止库存超卖](https://zhuanlan.zhihu.com/p/326806979)

## 7.[http](https://www.runoob.com/http/http-tutorial.html)

> [http的请求头](https://zhuanlan.zhihu.com/p/282737965)



> 各种返回值

## 8.session和cookie

Cookie 和 Session都是用来跟踪浏览器用户身份的会话方式，但是两者的应用场景不太一样。

>Cookie 

- **Cookie 一般用来保存用户信息** 比如①我们在 Cookie 中保存已经登录过得用户信息，下次访问网站的时候页面可以自动帮你登录的一些基本信息给填了；②一般的网站都会有保持登录也就是说下次你再访问网站的时候就不需要重新登录了，这是因为用户登录的时候我们可以存放了一个 Token 在 Cookie 中，下次登录的时候只需要根据 Token 值来查找用户即可(为了安全考虑，重新登录一般要将 Token 重写)；③登录一次网站后访问网站其他页面不需要重新登录。
- Cookie 数据保存在客户端(浏览器端)

>session

- **Session 的主要作用就是通过服务端记录用户的状态。** 典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了。
- Session 数据保存在服务器端，相对来说 Session 安全性更高。

## 9.java当中的线程池的使用场景

>池化技术，比如线程池、数据库连接池、http连接池；

- 池化技术的思想主要是为了减少每次获取资源的消耗，提高对资源的利用率；

>1.线程池的作用

      主要是为了提升系统的性能以及使用率。如果我们使用最简单的方式创建线程，当用户量比较大时就会产生很多创建和销毁线程的动作，这会导致服务器在创建和销毁线程上消耗的性能可能要比处理实际业务花费的时间和性能更多，线程池就是为了解决这种这种问题而出现的。
    
      同样思想的设计还有很多，比如**数据库连接池**。在实际开发中，如果没有数据库连接池的话就需要频繁的连接数据库，然而创建数据库的连接是一个很消耗性能的事情。

>2.[线程池的四种用法(ExecutorService)](https://cloud.tencent.com/developer/article/1529634)

1.**newCachedThreadPool**

- 当第二个任务开始，第一个任务已经执行结束，那么第二个任务会**复用**第一个任务创建的线程，并不会重新创建新的线程，提高了线程的复用率；
- 如果我们的业务需要一定的时间进行处理，这种方式可以根据业务场景自动的扩展线程数来处理我们的业务，但是**最多需要多少个线程同时处理**是我们无法控制的；

2.**newFixedThreadPool**

- 这种方式可以指定线程池中的**线程数**，可以通过控制**最大线程**来使我们的服务器达到最大的使用率，同时又可以保证即使流量突然增大也不会占用服务器过多的资源。

3.**newScheduledThreadPool**

- 该线程池支持**定时以及周期性**的任务执行
- 我们可以延迟任务的执行时间，也可以设置一个周期性的时间让任务重复执行。

4.**newSingleThreadExecutor**

- 这是一个单线程池，至始至终都由一个线程来执行。

>3.建议用法(ThreadPoolExecutor)

    使用 `ThreadPoolExecutor` 的构造函数声明线程池，避免使用`Executors` 类的 `newFixedThreadPool` 和 `newCachedThreadPool` ，因为可能会有 OOM (Out Of Menmory)的风险;

**ThreadPoolExecutor 3 个最重要的参数：**

- **`corePoolSize` :** 核心线程数线程数,定义了最小可以同时运行的线程数量。
- **`maximumPoolSize` :** 当队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。
- **`workQueue`:** 当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，会被存放在队列中。

**ThreadPoolExecutor其他常见参数:**

1. **`keepAliveTime`**:当线程池中的线程数量大于 `corePoolSize` 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 `keepAliveTime`才会被回收销毁；
2. **`unit`** : `keepAliveTime` 参数的时间单位。
3. **`threadFactory`** :executor 创建新线程的时候会用到。
4. **`handler`** :饱和策略。

>4.线程池的饱和策略

**ThreadPoolExecutor饱和策略定义:**

      如果当前同时运行的线程数量达到最大线程数量并且队列也已经被放满时，就会触发线程池的拒绝策略：

- **`ThreadPoolExecutor.AbortPolicy`**：抛出 `RejectedExecutionException`,让你感知到任务被拒绝了，然后便可以根据业务逻辑选择重试或者放弃提交等策略。
- **`ThreadPoolExecutor.CallerRunsPolicy`**：当有新任务提交后，如果线程池没被关闭且没有能力执行，则把这个任务交于提交任务的线程执行，也就是谁提交任务，谁就负责执行任务。但是如果任务提交速度过快，可能导致程序阻塞，性能效率上的损失较大。
- **`ThreadPoolExecutor.DiscardPolicy`：** 直接丢弃掉，无法感知；
- **`ThreadPoolExecutor.DiscardOldestPolicy`：** 如果线程池没被关闭且没有能力执行，则会丢弃**任务队列中的头结点**，通常是存活时间最长的任务，这种策略将队列中存活时间最长的线程丢弃掉，这样就可以腾出空间给新提交的任务。

> 5.线程池的使用场景

- **异步发送邮件通知**

  发送一个任务，然后注入到线程池中异步发送。

- **心跳请求任务**

  创建一个任务，然后定时发送请求到线程池中。