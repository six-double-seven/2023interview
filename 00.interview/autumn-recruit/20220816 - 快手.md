# 20220816 - 快手

# 1. IOC&&AOP

>IOC (Inverse of Control:控制反转)

- IOC控制反转是一种设计思想，控制指的是对象创建和管理的权力，反转是指将控制权交给外部环境(spring框架、Ioc容器)。即 将原本在程序中手动创建对象的控制权交由spring框架管理；
- 将对象之间的相互依赖关系交给Ioc容器管理，并由Ioc容器完成对象的注入。当我们需要创建一个对象时，只需要使用注解注入即可，而不用关心对象是怎么创建的；
- 之前在学校有一门课程是使用servlet+jsp完成web开发，当时各种service的创建就是手动new的，这个代码我现在是一点都不敢动，紧接着课设的时候使用springboot搭建的后台，切实的感受到了Ioc的震撼；
- 另外之前使用过微软的xamarin.Forms，其中包含simpleIOC容器，和spring的Ioc是相同的思想，需要在ViewModelLocator的类中将对象注入，使用的时候在容器中取出。

>AOP(Aspect-Oriented Programming:面向切面编程)

- 所谓面向切面编程，就是将那些与业务无关、却被业务模块共同调用的逻辑或责任(事务处理、日志管理)封装起来，避免代码冗余；
- 不改变原来代码的情况下，实现对原有功能的增强，是AOP的核心；
- AOP是基于动态代理的
  - 要代理的对象实现了某个接口，使用**JDK Proxy**创建代理对象
  - 没有实现接口的对象， 使用**Cglib** 生成一个被代理对象的子类来作为代理

# 2. 线程池

## 2.1 如何创建线程池

**方式一：通过构造方法实现**   ThredPoolExecutor()

**方式二：通过Executors工具类实现** ，该工具类可以创建三种类型的ThreadPoolExecutor

- **FixedThreadPool** ： 该方法返回一个固定线程数量的线程池。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。
- **SingleThreadExecutor：** 方法返回一个只有一个线程的线程池。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。
- **CachedThreadPool：** 该方法返回一个可根据实际情况调整线程数量的线程池。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。
- **ScheduledThreadPool：**通过Executors的newScheduledThreadPool方式创建，ScheduledThreadPool这类线程池主要用于执行定时任务和具有固定时期的重复任务。



## 2.2 Executors 返回线程池对象的弊端

- **FixedThreadPool 和 SingleThreadExecutor** ： 允许请求的队列长度为 Integer.MAX_VALUE ，可能堆积大量的请求，从而导致 OOM。
- **CachedThreadPool 和 ScheduledThreadPool** ： 允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致 OOM。



## 2.3 ThreadPoolExecutor

> ThreadPoolExecutor 3 个最重要的参数

- **`corePoolSize` :** 核心线程数定义了最小可以同时运行的线程数量。
- **`maximumPoolSize` :** 当队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。
- **`workQueue`:** 当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。

> ThreadPoolExecutor其他常见参数:

1. **`keepAliveTime`**:当线程池中的线程数量大于 `corePoolSize` 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 `keepAliveTime`才会被回收销毁；
2. **`unit`** : `keepAliveTime` 参数的时间单位。
3. **`threadFactory`** :executor 创建新线程的时候会用到。
4. **`handler`** :饱和策略。关于饱和策略下面单独介绍一下。

>饱和策略

如果当前同时运行的线程数量达到最大线程数量并且队列也已经被放满了任务时，ThreadPoolTaskExecutor 定义一些策略:

- **ThreadPoolExecutor.AbortPolicy：** 抛出 RejectedExecutionException来拒绝新任务的处理。
- **ThreadPoolExecutor.CallerRunsPolicy：** 调用执行自己的线程运行任务，也就是直接在调用`execute`方法的线程中运行(`run`)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。
- **ThreadPoolExecutor.DiscardPolicy：** 不处理新任务，直接丢弃掉。
- **ThreadPoolExecutor.DiscardOldestPolicy：** 此策略将丢弃最早的未处理的任务请求。



## 2.3 线程池执行的过程

执行过程如下图。

![图解线程池实现原理](https://javaguide.cn/assets/%E5%9B%BE%E8%A7%A3%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.2b9eb21a.png)



## 2.4 线程池大小确定

>背景

- 如果我们设置的线程池数量太小的话，如果同一时间有大量任务/请求需要处理，可能会导致大量的请求/任务在任务队列中排队等待执行，甚至会出现任务队列满了之后任务/请求无法处理的情况，或者大量任务堆积在任务队列导致 OOM。这样很明显是有问题的！ CPU 根本没有得到充分利用。
- 如果我们设置线程数量太大，大量线程可能会同时在争取 CPU 资源，这样会导致大量的上下文切换，从而增加线程的执行时间，影响了整体执行效率。

>常用公式

- **CPU 密集型任务(N+1)：** 这种任务消耗的主要是 CPU 资源，可以将线程数设置为 N（CPU 核心数）+1，比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。
- **I/O 密集型任务(2N)：** 这种任务应用起来，系统会用大部分的时间来处理 I/O 交互，而线程在处理 I/O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用。因此在 I/O 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 2N。

> CPU 密集任务 & IO 密集任务

- CPU 密集型简单理解就是利用 CPU 计算能力的任务，比如你在内存中对大量数据进行排序
- 但凡涉及到网络读取，文件读取这类都是 IO 密集型，这类任务的特点是 CPU 计算耗费时间相比于等待 IO 操作完成的时间来说很少，大部分时间都花在了等待 IO 操作完成上。

## 2.5 Q&A

coresize = 16，maxsize = 20，有界队列，队列长度为10，使用的是默认的拒绝策略，假设现在有16个任务正在运行，则第17个任务进来会发生什么？

> TODO

# 3.Collection接口下面的实现类

>集合的概述

- java集合也叫做容器，由两大接口派生而来，分别为colletcion和map两个接口；
  ![](http://six-double-seven.oss-cn-beijing.aliyuncs.com/img/java-collection-hierarchy.1727461b.png)

# 4.CPU调度、优缺点及使用场景

**1. 先到先服务(FCFS)调度算法**

- 从就绪队列中选择一个最先进入该队列的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度；
- 优点：实现容易；
- 缺点：FCFS 调度算法是非抢占的。一旦 CPU 分配给了一个进程，该进程就会使用 CPU 直到释放 CPU 为止，即程序终止或是请求 I/O。此外允许一个进程使用 CPU 过长将是个严重错误。

**2. 短作业优先(SJF)的调度算法** 

- 从就绪队列中选出一个估计运行时间最短的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度；
- 优点：考虑到作业的服务时间情况，降低了周转时间等相应时间；
- 缺点：可能会造成长时间的饥饿。

**3. 时间片轮转调度算法** 

- 时间片轮转调度是一种最古老，最简单，最公平且使用最广的算法，又称 RR(Round robin)调度。每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的时间。

**4. 多级反馈队列调度算法**

- 前面介绍的几种进程调度的算法都有一定的局限性。如**短进程优先的调度算法，仅照顾了短进程而忽略了长进程** 。多级反馈队列调度算法既能使高优先级的作业得到响应又能使短作业（进程）迅速完成。，因而它是目前**被公认的一种较好的进程调度算法**，UNIX 操作系统采取的便是这种调度算法。

**5. 优先级调度** 

- 为每个流程分配优先级，首先执行具有最高优先级的进程，依此类推。具有相同优先级的进程以 FCFS 方式执行。可以根据内存要求，时间要求或任何其他资源要求来确定优先级；
- 优点：可以赋予重要的进程以高优先级以确保宽耍任务能够得到CPU时间；
- 缺点：低优先级的进程口 能会饥饿。


